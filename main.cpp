// Copyright 2025 Medvedev Dan (Firegreat)

/*
Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
*/

// Server - side messenger part, written in C++17.
// For course project
// TODO: Crossplatform: works for Windows and Linux.



#include "Logger.h"
#include "SocketListener.h"
#include "ClientConnection.h"
#include "json.hpp"

#pragma comment(lib, "Ws2_32.lib")  // Link Winsock library

int main(int argc, char** argv)
{
    // The messenger won't be able to run properly on machines with byte size larger than 8 bits.
    static_assert(CHAR_BIT == 8, "Architectures with byte size larger than 8 are unsupported.");
    Logger& logger = Logger::getInstance();

    // TODO: determine the machine's endianness.

    // The server contains a listener. If the listener fails to initialize, the server will shut down.
    // Otherwise, the listener runs in a loop and listens for incoming connections.
    // The listener would create a separate thread for each incoming connection.
    std::unique_ptr<SocketListener> ptrSock;
    try
    {
        ptrSock = std::make_unique<SocketListener>();
    }
    catch (std::runtime_error const& e)
    {
        logger.log("The server failed to initialize the socket listener. The server will shut down.");
        return 1;
    }
    logger.log("The socket listener has been initialized successfully.");
    
    // TODO: What happens if a function inside try block creates a new thread, and inside the new thread an exception occurs?
    try
    {
        ptrSock->listenForConnections(); // An infinite listen loop.
    }
    catch (std::exception const& e)
    {
        std::string msg = std::string("The listen loop threw an exception: ") + e.what();
        logger.log(msg);
        return 1;
    }
    return 0;
}