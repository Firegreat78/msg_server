// Copyright 2025 Medvedev Dan (https://github.com/Firegreat78)

/*
Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
*/

#include "DatabaseConnection.h"
#include "Logger.h"

DatabaseConnection& DatabaseConnection::getInstance()
{
    static DatabaseConnection obj;
    return obj;
}

DatabaseConnection::DatabaseConnection()
{
    Logger& logger = Logger::getInstance();
    std::string const db_uri = "postgresql://postgres:12345@localhost:5432/messenger_db";
    try
    {
        connection = std::make_unique<pqxx::connection>(db_uri);
    }

    catch (std::exception const& e)
    {
        std::string const msg = 
        std::string("Failed to initialize connection with the database. URI: ") + 
        db_uri + "; Exception thrown: " + e.what();
        logger.log(msg);
        std::exit(EXIT_FAILURE);
    }
    std::string const msg = 
    std::string("Connection with PostgreSQL database established. URI: ") + 
    db_uri;
    
    logger.log(msg);
}

DatabaseConnection::~DatabaseConnection()
{
    Logger& logger = Logger::getInstance();
    logger.log("Database connection released.");
}

// The 'is_online' field in the DB is already set to 'true' when this func executes
void DatabaseConnection::addLogonUser(size_t thr_id, int64_t user_id)
{
    std::lock_guard<std::mutex> lock(mutex);
    logon_user_ids[thr_id] = user_id;
    
    if (users_amount.count(user_id) == 0) users_amount[user_id] = 0;

    users_amount[user_id]++;
}

// This will be called if the thread is pending to delete for whatever reason
void DatabaseConnection::onLogonUserDisconnect(size_t thr_id)
{
    std::lock_guard<std::mutex> lock(mutex);
    
    // If the user is not authorized into some account (auth 
    // flag is cleared for this thread), we don't do anything
    if (logon_user_ids.count(thr_id) == 0) return;

    int64_t const logon_user_id = logon_user_ids[thr_id];
    
    // Clear authorization flag for a thread
    logon_user_ids.erase(thr_id);
    
    // Decrement the amount of authorizations to some account
    users_amount[logon_user_id]--;
    
    // If the current closed authorization is not the last one, we don't do anything
    // Otherwise we update the DB
    if (users_amount[logon_user_id] != 0) return;
    try
    {
        pqxx::work txn(*connection);
        txn.exec_params(
            "UPDATE users "
            "SET is_online = FALSE, last_seen_online = NOW() "
            "WHERE id = $1::integer AND is_online = TRUE",
            logon_user_id
        );
        txn.commit();
    }

    catch (pqxx::sql_error const& e)
    {
        std::string msg = std::string("pqxx::sql_error was thrown in DatabaseConnection::onLogonUserDisconnect: ") + e.what();
        Logger::getInstance().log(msg);
    }
    
    catch (std::exception const& e)
    {
        std::string msg = std::string("Some exception was thrown in DatabaseConnection::onLogonUserDisconnect: ") + e.what();
        Logger::getInstance().log(msg);
    }
}

json DatabaseConnection::loginHandler(json const& js)
{
    json response;
    pqxx::result query_result;
    std::string const login = js["login"].get<std::string>();
    std::string const password_hash = js["password_hash"].get<std::string>();
    std::string const user_info = std::string("(login=") + 
        login + "; password_hash=" + password_hash + ")";
    
    try
    {
        std::lock_guard<std::mutex> lock(mutex);
        pqxx::work txn(*connection);
        query_result = txn.exec_params(
            "SELECT * FROM users "
            "WHERE login = $1 AND password_hash = $2",
            login, password_hash
        );
        
        // no match - invalid login and/or password
        if (query_result.empty())
        return json {
            {"success", 0},
            {"reason", "Invalid login and/or password"},
        };
        int64_t const logon_user_id = query_result[0][0].as<int64_t>();
        std::string const username = query_result[0][2].as<std::string>();
        std::string const timestamp = query_result[0][4].as<std::string>();
        txn.exec_params(
            "UPDATE users "
            "SET is_online = TRUE "
            "WHERE id = $1",
            logon_user_id
        );
        txn.commit();
        
        // sending success response only after commit, just in case
        response["success"] = 1;
        response["id"] = logon_user_id;
        response["username"] = username;
        response["created_at"] = timestamp;
        std::string const msg = std::string("Login handler successfully handled user ") + user_info;
        Logger::getInstance().log(msg);
    }

    catch (pqxx::sql_error const& e)
    {
        std::string msg = std::string("pqxx::sql_error was thrown in loginHandler: ") + e.what();
        Logger::getInstance().log(msg);
        response["success"] = 0;
        response["reason"] = msg;
    }
    
    catch (std::exception const& e)
    {
        std::string msg = std::string("Some exception was thrown in loginHandler: ") + e.what();
        Logger::getInstance().log(msg);
        response["success"] = 0;
        response["reason"] = msg;
    }
    return response;
}

json DatabaseConnection::registerHandler(json const& js)
{
    json response;
    pqxx::result query_result;
    std::string const login = js["login"].get<std::string>();
    std::string const username = js["username"].get<std::string>();
    std::string const password_hash = js["password_hash"].get<std::string>();
    std::string const user_info = std::string("(login=") + login + 
        ", username=" + username + ", password_hash=" + password_hash + ")";
    try
    {
        std::lock_guard<std::mutex> lock(mutex);
        pqxx::work txn(*connection);
        // TODO: add check for existing row before inserting so the primary key won't increment
        // This increments PK on failure
        query_result = txn.exec_params(
            "INSERT INTO users (login, username, password_hash) "
            "VALUES ($1, $2, $3)", 
            login, username, password_hash
        );
        txn.commit();
        std::string const msg = std::string("New user ") + user_info + 
            "has been added to the 'users' database.";
        Logger::getInstance().log(msg);
        response["success"] = 1;
    }

    catch (pqxx::unique_violation const& e)
    {
        std::string const msg = std::string("New user ") + user_info + 
            "has not been added to the 'users' database. pqxx::unique_violation exception was thrown: " + 
            e.what();
        Logger::getInstance().log(msg);
        response["reason"] = "An account with given login and/or username already exists";
        response["success"] = 0;
    }

    catch (pqxx::sql_error const& e)
    {
        std::string const msg = std::string("New user ") + user_info + 
            "has not been added to the 'users' database. pqxx::sql_error exception was thrown: " + 
            e.what();
        Logger::getInstance().log(msg);
        response["reason"] = std::string("An error occurred with database query: ") + e.what();
        response["success"] = 0;
    }

    catch (std::exception const& e)
    {
        std::string const msg = std::string("New user ") + user_info + 
            "has not been added to the 'users' database. std::exception was thrown: " + 
            e.what();
        Logger::getInstance().log(msg);
        response["reason"] = std::string("An unexpected error occurred: ") + e.what();
        response["success"] = 0;
    }
    return response;
}

json DatabaseConnection::changeUsernameHandler(json const& js)
{
    json response;
    int64_t const id = js["id"].get<int64_t>();
    std::string const new_username = js["new_username"].get<std::string>();
    try
    {
        std::lock_guard<std::mutex> lock(mutex);
        pqxx::work txn(*connection);
        txn.exec_params(
            "UPDATE users "
            "SET username = $1 "
            "WHERE id = $2",
            new_username, id
        );
        txn.commit();
        response["success"] = 1;
    }
    
    catch (pqxx::sql_error const& e)
    {
        response["success"] = 0;
        response["reason"] = std::string("pqxx::sql_error occurred: ") + e.what();
    }

    catch (std::exception const& e)
    {
        response["success"] = 0;
    }
    
    return response;
}

json DatabaseConnection::changePasswordHandler(json const& js)
{
    json response;
    int64_t const id = js["id"].get<int64_t>();
    std::string const new_password_hash = js["new_password_hash"].get<std::string>();
    try
    {
        std::lock_guard<std::mutex> lock(mutex);
        pqxx::work txn(*connection);
        txn.exec_params(
            "UPDATE users "
            "SET password_hash = $1 "
            "WHERE id = $2",
            new_password_hash, id
        );
        txn.commit();
        response["success"] = 1;
    }

    catch (pqxx::sql_error const& e)
    {
        response["success"] = 0;
        response["reason"] = std::string("pqxx::sql_error occurred: ") + e.what();
    }

    catch (std::exception const& e)
    {
        response["success"] = 0;
        response["reason"] = std::string("std::exception occurred: ") + e.what();
    }
    
    return response;
}

json DatabaseConnection::exitAccountHandler(json const& js)
{
    json response;
    int64_t const id = js["id"].get<int64_t>();
    std::lock_guard<std::mutex> lock(mutex);
    try
    {
        pqxx::work txn(*connection);
        txn.exec_params(
            "UPDATE users "
            "SET is_online = FALSE, last_seen_online = NOW() "
            "WHERE id = $1 AND is_online = TRUE",
            id
        );
        txn.commit();
        response["success"] = 1;
    }

    catch (pqxx::sql_error const& e)
    {
        response["success"] = 0;
        response["reason"] = std::string("pqxx::sql_error occurred: ") + e.what();
    }

    catch (std::exception const& e)
    {
        response["success"] = 0;
        response["reason"] = std::string("std::exception occurred: ") + e.what();
    }

    return response;
}

// TODO: add group chats
json DatabaseConnection::updateChatListHandler(json const& js)
{
    json response;
    int64_t const user_id = js["id"].get<int64_t>();
    pqxx::result query_result;
    try
    {
        std::lock_guard<std::mutex> lock(mutex);
        pqxx::work txn(*connection);

        query_result = txn.exec_params(
            "SELECT u.id AS other_user_id, u.username, pc.chat_id, m.content, "
            "date_trunc('second', m.sent_at) as sent_at, "
            "sender.username AS last_message_sender_username, "
            "target.is_online AS other_user_is_online, "
            "date_trunc('second', target.last_seen_online) AS other_user_last_seen_online, "
            "COALESCE(unread.unread_count, 0) AS unread_count "
            "FROM (SELECT id, username FROM users WHERE id != $1) AS u "
            "LEFT JOIN LATERAL ( "
            "SELECT pc.chat_id FROM private_chat pc "
            "WHERE pc.user1_id = LEAST($1::integer, u.id) "
            "AND pc.user2_id = GREATEST($1::integer, u.id) "
            ") AS pc ON true "
            "LEFT JOIN LATERAL ( "
            "SELECT m.* FROM message m "
            "WHERE m.chat_id = pc.chat_id AND NOT m.is_deleted "
            "ORDER BY m.id DESC "
            "LIMIT 1 "
            ") AS m ON true "
            "LEFT JOIN users sender ON sender.id = m.sender_id "
            "LEFT JOIN users target ON target.id = u.id "
            "LEFT JOIN LATERAL ( "
            "SELECT COUNT(*) AS unread_count "
            "FROM message m2 "
            "WHERE m2.chat_id = pc.chat_id "
            "AND m2.sender_id = u.id "
            "AND m2.is_deleted = FALSE "
            "AND m2.is_read = FALSE "
            ") AS unread ON true "
            "ORDER BY 1",
            user_id
        );
        txn.commit();
        json ids = json::array();
        json usernames = json::array();
        json chat_ids = json::array();
        json last_msg_contents = json::array();
        json last_msg_ts = json::array();
        json last_msg_username = json::array();
        json online_statuses = json::array();
        json last_seen_online = json::array();
        json unread_msgs_cnt = json::array();
        for (const auto& row : query_result)
        {
            ids.push_back(row[0].as<int64_t>());

            usernames.push_back(std::string("@") + row[1].as<std::string>());
            
            if (row[2].is_null()) chat_ids.push_back(nullptr);
            else chat_ids.push_back(row[2].as<int64_t>());

            if (row[3].is_null()) last_msg_contents.push_back(nullptr);
            else last_msg_contents.push_back(row[3].as<std::string>());

            if (row[4].is_null()) last_msg_ts.push_back(nullptr);
            else last_msg_ts.push_back(row[4].as<std::string>());

            if (row[5].is_null()) last_msg_username.push_back(nullptr);
            else last_msg_username.push_back(std::string("@") + row[5].as<std::string>());

            online_statuses.push_back(row[6].as<bool>());

            if (row[7].is_null()) last_seen_online.push_back(nullptr);
            else last_seen_online.push_back(row[7].as<std::string>());

            unread_msgs_cnt.push_back(row[8].as<int64_t>());
        }
        response["user_ids"] = ids;
        response["usernames"] = usernames;
        response["chat_ids"] = chat_ids;
        response["last_msg_contents"] = last_msg_contents;
        response["last_msg_ts"] = last_msg_ts;
        response["last_msg_username"] = last_msg_username;
        response["online_statuses"] = online_statuses;
        response["last_seen_online"] = last_seen_online;
        response["unread_msgs_cnt"] = unread_msgs_cnt;
        response["success"] = 1;
    }

    catch (pqxx::sql_error const& e)
    {
        response["success"] = 0;
        response["reason"] = std::string("pqxx::sql_error occurred: ") + e.what();
    }

    catch (std::exception const& e)
    {
        response["success"] = 0;
        response["reason"] = std::string("std::exception occurred: ") + e.what();
    }
    return response;
}

json DatabaseConnection::renewChatListInfoHandler(json const& js)
{
    json response;
    pqxx::result query_result;
    int64_t const logon_user_id = js["logon_user_id"].get<int64_t>();
    std::vector<int64_t> const users_ids = js["users_ids"].get<std::vector<int64_t>>();
    try
    {
        std::lock_guard<std::mutex> lock(mutex);
        pqxx::work txn(*connection);
        
        query_result = txn.exec_params(
            "SELECT u.id AS other_user_id, u.username, pc.chat_id, m.content, "
            "date_trunc('second', m.sent_at) as sent_at, "
            "sender.username AS last_message_sender_username, "
            "target.is_online AS other_user_is_online, "
            "date_trunc('second', target.last_seen_online) AS other_user_last_seen_online, "
            "COALESCE(unread.unread_count, 0) AS unread_count "
            "FROM (SELECT id, username FROM users WHERE id = ANY($1)) AS u "
            "LEFT JOIN LATERAL ( "
            "SELECT pc.chat_id FROM private_chat pc "
            "WHERE pc.user1_id = LEAST($2::integer, u.id) "
            "AND pc.user2_id = GREATEST($2::integer, u.id) "
            ") AS pc ON true "
            "LEFT JOIN LATERAL ( "
            "SELECT m.* FROM message m "
            "WHERE m.chat_id = pc.chat_id AND NOT m.is_deleted "
            "ORDER BY m.id DESC "
            "LIMIT 1 "
            ") AS m ON true "
            "LEFT JOIN users sender ON sender.id = m.sender_id "
            "LEFT JOIN users target ON target.id = u.id "
            "LEFT JOIN LATERAL ( "
            "SELECT COUNT(*) AS unread_count "
            "FROM message m2 "
            "WHERE m2.chat_id = pc.chat_id "
            "AND m2.sender_id = u.id "
            "AND m2.is_deleted = FALSE "
            "AND m2.is_read = FALSE "
            ") AS unread ON true "
            "ORDER BY 1",
            users_ids, logon_user_id
        );
        txn.commit();
        
        json ids = json::array();
        json usernames = json::array();
        json chat_ids = json::array();
        json last_msg_contents = json::array();
        json last_msg_ts = json::array();
        json last_msg_username = json::array();
        json online_statuses = json::array();
        json last_seen_online = json::array();
        json unread_msgs_cnt = json::array();
        for (const auto& row : query_result)
        {
            ids.push_back(row[0].as<int64_t>());

            usernames.push_back(std::string("@") + row[1].as<std::string>());
            
            if (row[2].is_null()) chat_ids.push_back(nullptr);
            else chat_ids.push_back(row[2].as<int64_t>());

            if (row[3].is_null()) last_msg_contents.push_back(nullptr);
            else last_msg_contents.push_back(row[3].as<std::string>());

            if (row[4].is_null()) last_msg_ts.push_back(nullptr);
            else last_msg_ts.push_back(row[4].as<std::string>());

            if (row[5].is_null()) last_msg_username.push_back(nullptr);
            else last_msg_username.push_back(std::string("@") + row[5].as<std::string>());

            online_statuses.push_back(row[6].as<bool>());

            if (row[7].is_null()) last_seen_online.push_back(nullptr);
            else last_seen_online.push_back(row[7].as<std::string>());

            unread_msgs_cnt.push_back(row[8].as<int64_t>());
        }
        response["user_ids"] = ids;
        response["usernames"] = usernames;
        response["chat_ids"] = chat_ids;
        response["last_msg_contents"] = last_msg_contents;
        response["last_msg_ts"] = last_msg_ts;
        response["last_msg_username"] = last_msg_username;
        response["online_statuses"] = online_statuses;
        response["last_seen_online"] = last_seen_online;
        response["unread_msgs_cnt"] = unread_msgs_cnt;
        response["success"] = 1;
    }

    catch (pqxx::sql_error const& e)
    {
        response["success"] = 0;
        response["reason"] = std::string("pqxx::sql_error occurred: ") + e.what();
    }

    catch (std::exception const& e)
    {
        response["success"] = 0;
        response["reason"] = std::string("std::exception occurred: ") + e.what();
    }
    return response;
}

json DatabaseConnection::getChatMessages(pqxx::result const& message_list)
{
    json messages_array = json::array();
    for (auto const& row : message_list)
    {
        json message;
        message["id"] = row[0].as<int64_t>();
        message["sender_id"] = row[2].as<int64_t>();
        
        if (row[3].is_null())
        {
            message["reply_to_id"] = nullptr;
            message["replied_message_content"] = nullptr;
        }
        else
        {
            message["reply_to_id"] = row[3].as<int64_t>();
            message["replied_message_content"] = row[6].as<std::string>();
        }
        
        message["content"] = row[4].as<std::string>();
        
        message["sent_at"] = row[5].as<std::string>();
        
        message["sender_username"] = row[7].as<std::string>();
        
        message["has_reply"] = row[8].as<bool>();
        
        message["is_deleted"] = row[9].as<bool>();
        
        if (row[10].is_null()) message["last_edited"] = nullptr;
        else message["last_edited"] = row[10].as<std::string>();

        if (row[11].is_null()) 
        {
            message["replied_msg_deleted"] = false;
            message["reply_to_user_id"] = nullptr;
            message["replied_username"] = nullptr;
        }
        else 
        {
            message["replied_msg_deleted"] = row[11].as<bool>();
            message["reply_to_user_id"] = row[12].as<int64_t>();
            message["reply_to_username"] = row[13].as<std::string>();
        }
        message["is_read_by_other"] = row[14].as<bool>();
        messages_array.push_back(message);
    }
    return messages_array;
}

// This is for initial loading of chat's messages.
// Chat loading when the user double-clicks it on the left.
// When the user selects a chat, we will get the oldest unread message in the chat.
// In case when such message exists, we will load it and neighbour messages.
// In case when there's no such message, we will load N newest messages.
// Filters are automatically disabled in this case.

json DatabaseConnection::chatLoadHandler(json const& js)
{
    json response;
    pqxx::result query_result;
    bool const is_private_chat = js["is_private_chat"].get<bool>();
    int64_t const sender_id = js["sender_id"].get<int64_t>();
    int64_t const msg_amount = js["msg_amount"].get<int64_t>();

    int64_t const cnt_msg_above = msg_amount/2 + (msg_amount % 2) - 1;
    int64_t const cnt_msg_below = msg_amount/2;
    try
    {
        std::lock_guard<std::mutex> lock(mutex);
        pqxx::work txn(*connection);
        int64_t chat_id;
        if (is_private_chat)
        {
            query_result = txn.exec_params(
                "SELECT get_private_chat_id($1, $2)",
                sender_id, js["recv_id"].get<int64_t>()
            );

            // we lazy initialize a private chat at the moment when a user sends first message.
            // if no chat (that is, if no messages between two users yet), then chat_id == 0
            chat_id = query_result[0][0].as<int64_t>();
        }

        else {} // group chat
        
        // Oldest unread msg in the chat
        // if chat_id == 0, then query_result will be 
        // empty here and afterwards so everything's ok
        query_result = txn.exec_params(
            "SELECT id FROM message m "
            "WHERE (NOT m.is_deleted) AND "
            "(NOT m.is_read) AND "
            "m.chat_id = $1::integer AND "
            "m.sender_id != $2::integer "
            "ORDER BY 1",
            chat_id, sender_id
        );
        int64_t const oldest_unread_id = 
        query_result.empty() ? 0 : query_result[0][0].as<int64_t>();

        // If there's an unread msg, we will load messages around the first unread one.
        if (oldest_unread_id != 0)
        query_result = txn.exec_params(
            "WITH RECURSIVE "
            "params AS ( "
            "SELECT "
            "$3::integer AS total_messages, "
            "$4::integer AS preferred_before), "
            "target AS ( "
            "SELECT id FROM public.message "
            "WHERE id = $1::integer AND chat_id = $2::integer), "
            "before_messages_raw AS ( "
            "SELECT m.*, ROW_NUMBER() OVER (ORDER BY m.id DESC) AS rn "
            "FROM public.message m, target "
            "WHERE m.chat_id = $2::integer AND m.id < target.id AND NOT m.is_deleted), "
            "after_messages_raw AS ( "
            "SELECT m.*, ROW_NUMBER() OVER (ORDER BY m.id ASC) AS rn "
            "FROM public.message m, target "
            "WHERE m.chat_id = $2::integer AND m.id > target.id AND NOT m.is_deleted), "
            "before_count AS ( "
            "SELECT COUNT(*)::integer AS cnt FROM before_messages_raw), "
            "after_count AS ( "
            "SELECT COUNT(*)::integer AS cnt FROM after_messages_raw), "
            "limits AS ( "
            "SELECT  "
            "p.total_messages, "
            "p.preferred_before, "
            "LEAST(p.preferred_before, bc.cnt) AS before_limit, "
            "LEAST(p.total_messages - 1 - LEAST(p.preferred_before, bc.cnt), ac.cnt) AS after_limit "
            "FROM params p "
            "JOIN before_count bc ON true "
            "JOIN after_count ac ON true), "
            "before_messages AS ( "
            "SELECT m.* "
            "FROM before_messages_raw m, limits "
            "WHERE m.rn <= limits.before_limit), "
            "after_messages AS ( "
            "SELECT m.* "
            "FROM after_messages_raw m, limits "
            "WHERE m.rn <= limits.after_limit), "
            "target_message AS ( "
            "SELECT *, 0 AS rn "
            "FROM public.message "
            "WHERE id = $1::integer AND chat_id = $2::integer), "
            "full_set AS ( "
            "SELECT * FROM before_messages "
            "UNION ALL "
            "SELECT * FROM target_message "
            "UNION ALL "
            "SELECT * FROM after_messages) "
            "SELECT m.id, m.chat_id, m.sender_id, "
            "m.reply_to_id, m.content AS message_content, "
            "date_trunc('second', m.sent_at) AS sent_at, "
            "replied_message.content AS replied_message_content, "
            "u.username, m.has_reply, m.is_deleted, "
            "date_trunc('second', m.last_edited) AS last_edited, "
            "replied_message.is_deleted AS is_reply_deleted, "
            "replied_message.sender_id AS reply_to_user_id, "
            "replied_user.username AS reply_to_username, m.is_read "
            "FROM full_set m "
            "LEFT JOIN public.message AS replied_message ON m.reply_to_id = replied_message.id "
            "JOIN public.users AS u ON m.sender_id = u.id "
            "LEFT JOIN public.users AS replied_user ON replied_message.sender_id = replied_user.id "
            "ORDER BY m.id",
            oldest_unread_id, chat_id, 
            cnt_msg_above + cnt_msg_below + 1, 
            cnt_msg_above
        );
        
        // If there's no unread msg, we will load last N messages from the chat.
        else 
        query_result = txn.exec_params(
            "SELECT * FROM ( "
            "SELECT m.id, m.chat_id, m.sender_id, m.reply_to_id, "
            "m.content AS message_content, date_trunc('second', m.sent_at) AS sent_at, "
            "replied_message.content AS replied_message_content, "
            "u.username, m.has_reply, m.is_deleted, date_trunc('second', m.last_edited), replied_message.is_deleted, "
            "replied_message.sender_id, replied_user.username, m.is_read "
            "FROM public.message AS m "
            "LEFT JOIN public.message AS replied_message ON m.reply_to_id = replied_message.id "
            "JOIN public.users AS u ON m.sender_id = u.id "
            "LEFT JOIN public.users AS replied_user ON replied_message.sender_id = replied_user.id "
            "WHERE (NOT m.is_deleted) AND "
            "m.chat_id = $1::integer "
            "ORDER BY m.id DESC "
            "LIMIT $2 "
            ") AS sub "
            "ORDER BY sub.id ASC",
            chat_id, msg_amount
        );

        txn.commit();
        response["success"] = 1;
        response["chat_id"] = chat_id;
        response["oldest_unread_id"] = oldest_unread_id;
        response["messages"] = getChatMessages(query_result); // empty array if chat_id == 0
    }
    
    catch (pqxx::sql_error const& e)
    {
        response["success"] = 0;
        response["reason"] = std::string("pqxx::sql_error occurred: ") + e.what();
    }

    catch (std::exception const& e)
    {
        response["success"] = 0;
        response["reason"] = std::string("std::exception occurred: ") + e.what();
    }
    return response;
}

json DatabaseConnection::chatLoadFilterHandler(json const& js)
{
    json response;
    pqxx::result query_result;
    bool const is_private_chat = js["is_private_chat"].get<bool>();
    int64_t const sender_id = js["sender_id"].get<int64_t>();
    int64_t const msg_amount = js["msg_amount"].get<int64_t>();
    
    std::string const filter_content = js["filter_content"].get<std::string>();
    
    bool const filter_dt_enabled = js["filter_dt_enabled"].get<bool>();

    // If datetime filter is disabled, we put the dummy values here
    std::string const filter_dt_begin = filter_dt_enabled ? 
    js["filter_dt_begin"].get<std::string>() : "2000-01-01 00:00:00Z";
    std::string const filter_dt_end = filter_dt_enabled ? 
    js["filter_dt_end"].get<std::string>() : "2000-01-01 00:00:00Z";

    bool const filter_unread_enabled = js["filter_unread_enabled"].get<bool>();
    int64_t const logon_user_id = js["user_id"].get<int64_t>();

    try
    {
        std::lock_guard<std::mutex> lock(mutex);
        pqxx::work txn(*connection);
        int64_t chat_id;
        if (is_private_chat)
        {
            query_result = txn.exec_params(
                "SELECT get_private_chat_id($1, $2)",
                sender_id, js["recv_id"].get<int64_t>()
            );

            // we lazy initialize a private chat at the moment when a user sends first message.
            // if no chat (that is, if no messages between two users yet), then chat_id == 0
            chat_id = query_result[0][0].as<int64_t>();
        }

        else {} // group chat

        query_result = txn.exec_params(
            "SELECT * FROM ( "
            "SELECT m.id, m.chat_id, m.sender_id, m.reply_to_id, "
            "m.content AS message_content, date_trunc('second', m.sent_at) AS sent_at, "
            "replied_message.content AS replied_message_content, "
            "u.username, m.has_reply, m.is_deleted, date_trunc('second', m.last_edited), replied_message.is_deleted, "
            "replied_message.sender_id, replied_user.username, m.is_read "
            "FROM public.message AS m "
            "LEFT JOIN public.message AS replied_message ON m.reply_to_id = replied_message.id "
            "JOIN public.users AS u ON m.sender_id = u.id "
            "LEFT JOIN public.users AS replied_user ON replied_message.sender_id = replied_user.id "
            "WHERE (NOT m.is_deleted) AND "
            "m.chat_id = $1::integer AND "
            "( ($4) OR (m.content LIKE '%' || $3 || '%' ESCAPE '\\') ) AND "
            "( (NOT $5) OR (m.sent_at >= $6::timestamptz AND m.sent_at <= $7::timestamptz) ) AND "
            "( (NOT $8) OR (NOT m.is_read AND m.sender_id != $9::integer) ) "
            "ORDER BY m.id DESC "
            "LIMIT $2 "
            ") AS sub "
            "ORDER BY sub.id ASC",
            chat_id, msg_amount, 
            filter_content, static_cast<bool>(filter_content.length() == 0),
            filter_dt_enabled, filter_dt_begin, filter_dt_end,
            filter_unread_enabled, logon_user_id
        );
        txn.commit();
        response["success"] = 1;
        response["messages"] = getChatMessages(query_result);
    }

    catch (pqxx::sql_error const& e)
    {
        response["success"] = 0;
        response["reason"] = std::string("pqxx::sql_error occurred: ") + e.what();
    }

    catch (std::exception const& e)
    {
        response["success"] = 0;
        response["reason"] = std::string("std::exception occurred: ") + e.what();
    }
    return response;
}

json DatabaseConnection::sendMsgHandler(json const& js)
{
    json response;
    pqxx::result query_result;
    int64_t const sender_id = js["sender_id"].get<int64_t>();
    
    // if chat_id == 0 here, then private (yet to be lazy initialized).
    // We will overwrite it with the newly created one in case of lazy initialization.
    int64_t chat_id = js["chat_id"].get<int64_t>();
    
    std::string const content = js["content"].get<std::string>();
    bool const update_chat_id = (chat_id == 0);
    try
    {
        std::lock_guard<std::mutex> lock(mutex);
        pqxx::work txn(*connection);
        query_result = txn.exec_params(
            "SELECT * FROM is_private_chat($1::integer)",
            chat_id // if chat_id == 0, then func returns 'true'
        );
        

        bool const is_private_chat = query_result[0][0].as<bool>();
        if (is_private_chat)
        {
            int64_t const recv_id = js["receiver_id"].get<int64_t>();
            query_result = txn.exec_params(
                "SELECT create_or_get_private_chat($1, $2)",
                sender_id, recv_id
            );

            // chat_id holds a valid id here even if it was lazy initialized just now
            chat_id = query_result[0][0].as<int64_t>();
            
            // add this to response so frontend client can apply it
            // or it won't be able to fetch/update messages via timer
            if (update_chat_id) response["chat_id"] = chat_id;

        }
        else // group chat (fetch chat id)
        {

        }
        // after fetching desired chat id (group/private), we are ready to send the message.
        
        // if reply_to_id == 0 then there was no answer
        int64_t const reply_to_id = js.value("answer_to", 0);
        bool has_reply = false;
        if (reply_to_id != 0)
        {
            query_result = txn.exec_params(
                "SELECT m.is_deleted "
                "FROM public.message AS m "
                "WHERE m.id = $1",
                reply_to_id
            );
            bool const msg_deleted = query_result[0][0].as<bool>();
            if (!msg_deleted) has_reply = true;
        }


        if (!has_reply) // pending answer msg was deleted after json arrival or this is not reply
        {
            query_result = txn.exec_params(
                "INSERT INTO message (chat_id, sender_id, content) "
                "VALUES "
                "($1::integer, $2::integer, $3::text)",
                chat_id, sender_id, content
            );
        }
        else
        {
            query_result = txn.exec_params(
                "INSERT INTO message (chat_id, sender_id, content, "
                "reply_to_id, has_reply) "
                "VALUES "
                "($1::integer, $2::integer, $3::text, $4::integer, $5::bool)",
                chat_id, sender_id, content, reply_to_id, true
            );
        }
        txn.commit();
        response["success"] = 1;
    }

    catch (pqxx::sql_error const& e)
    {
        response["success"] = 0;
        response["reason"] = std::string("pqxx::sql_error occurred: ") + e.what();
    }

    catch (std::exception const& e)
    {
        response["success"] = 0;
        response["reason"] = std::string("std::exception occurred: ") + e.what();
    }

    return response;
}

json DatabaseConnection::updateMessageHandler(json const& js)
{
    json response;
    int64_t const msg_id = js["msg_id"].get<int64_t>();
    std::string const content = js["new_content"].get<std::string>();

    try
    {
        std::lock_guard<std::mutex> lock(mutex);
        pqxx::work txn(*connection);
        txn.exec_params(
            "UPDATE message "
            "SET content = $1, last_edited = NOW() "
            "WHERE id = $2",
            content, msg_id
        );
        txn.commit();
        response["success"] = 1;
    }

    catch (pqxx::sql_error const& e)
    {
        response["success"] = 0;
        response["reason"] = std::string("pqxx::sql_error occurred: ") + e.what();
    }

    catch (std::exception const& e)
    {
        response["success"] = 0;
        response["reason"] = std::string("std::exception occurred: ") + e.what();
    }
    return response;
}

json DatabaseConnection::deleteMessageHandler(json const& js)
{
    json response;
    int64_t const msg_id = js["id"].get<int64_t>();
    try
    {
        std::lock_guard<std::mutex> lock(mutex);
        pqxx::work txn(*connection);
        txn.exec_params(
            "UPDATE message "
            "SET is_deleted = TRUE "
            "WHERE id = $1",
            msg_id
        );
        txn.commit();
        response["success"] = 1;
    }
    catch (pqxx::sql_error const& e)
    {
        response["success"] = 0;
        response["reason"] = std::string("pqxx::sql_error occurred: ") + e.what();
    }

    catch (std::exception const& e)
    {
        response["success"] = 0;
        response["reason"] = std::string("std::exception occurred: ") + e.what();
    }
    return response;
}

json DatabaseConnection::getArrivedMsgHandler(json const& js)
{
    json response;
    pqxx::result query_result;
    int64_t const chat_id = js["chat_id"].get<int64_t>(); // guaranteed not 0
    int64_t const frontend_last_msg_id = js["last_msg_id"].get<int64_t>();
    
    std::string const filter_content = js["filter_content"].get<std::string>();
    bool const filter_dt_enabled = js["filter_dt_enabled"].get<bool>();
    
    // If datetime filter is disabled, we put the dummy values here
    std::string const filter_dt_begin = filter_dt_enabled ? 
    js["filter_dt_begin"].get<std::string>() : "2000-01-01 00:00:00Z";
    std::string const filter_dt_end = filter_dt_enabled ? 
    js["filter_dt_end"].get<std::string>() : "2000-01-01 00:00:00Z";

    int64_t const msg_amount = js["msg_amount"].get<int64_t>();
    
    bool const filter_unread_enabled = js["filter_unread_enabled"].get<bool>();
    int64_t const logon_user_id = js["user_id"].get<int64_t>();

    try
    {
        std::lock_guard<std::mutex> lock(mutex);
        pqxx::work txn(*connection);
        
        // messages after other msg
        query_result = txn.exec_params(
            "SELECT m.id, m.chat_id, m.sender_id, "
            "m.reply_to_id, m.content AS message_content, "
		    "date_trunc('second', m.sent_at) as sent_at, "
            "replied_message.content AS replied_message_content, "
            "u.username, m.has_reply, m.is_deleted, date_trunc('second', m.last_edited), replied_message.is_deleted, "
            "replied_message.sender_id, replied_user.username, m.is_read "
            "FROM public.message AS m "
            "LEFT JOIN public.message AS replied_message ON m.reply_to_id = replied_message.id "
            "JOIN public.users AS u ON m.sender_id = u.id "
            "LEFT JOIN public.users AS replied_user ON replied_message.sender_id = replied_user.id "
            "WHERE (NOT m.is_deleted) AND "
            "m.chat_id = $1::integer AND "
            "m.id > $2::integer AND "
            "( ($4) OR (m.content LIKE '%' || $3 || '%' ESCAPE '\\') ) AND "
            "( (NOT $5) OR (m.sent_at >= $6::timestamptz AND m.sent_at <= $7::timestamptz) ) AND "
            "( (NOT $9) OR (NOT m.is_read AND m.sender_id != $10::integer) ) "
            "ORDER BY m.id ASC "
            "LIMIT $8",
            chat_id, frontend_last_msg_id, 
            filter_content, static_cast<bool>(filter_content.length() == 0),
            filter_dt_enabled, filter_dt_begin, filter_dt_end,
            msg_amount,
            filter_unread_enabled, logon_user_id
        );
        txn.commit();
        
        response["success"] = 1;
        response["messages"] = getChatMessages(query_result);
    }

    catch (pqxx::sql_error const& e)
    {
        response["success"] = 0;
        response["reason"] = std::string("pqxx::sql_error occurred: ") + e.what();
    }

    catch (std::exception const& e)
    {
        response["success"] = 0;
        response["reason"] = std::string("std::exception occurred: ") + e.what();
    }

    return response;
}

json DatabaseConnection::requestUpperMsgsHandler(json const& js)
{
    json response;
    pqxx::result query_result;
    int64_t const chat_id = js["chat_id"].get<int64_t>();
    int64_t const upper_msg_id = js["upper_msg_id"].get<int64_t>();
    
    std::string const filter_content = js["filter_content"].get<std::string>();
    bool const filter_dt_enabled = js["filter_dt_enabled"].get<bool>();
    
    // If datetime filter is disabled, we put the dummy values here
    std::string const filter_dt_begin = filter_dt_enabled ? 
    js["filter_dt_begin"].get<std::string>() : "2000-01-01 00:00:00Z";
    std::string const filter_dt_end = filter_dt_enabled ? 
    js["filter_dt_end"].get<std::string>() : "2000-01-01 00:00:00Z";

    int64_t const max_msg_amount = js["max_msg_amount"].get<int64_t>();
    
    bool const filter_unread_enabled = js["filter_unread_enabled"].get<bool>();
    int64_t const logon_user_id = js["user_id"].get<int64_t>();

    try
    {
        std::lock_guard<std::mutex> lock(mutex);
        pqxx::work txn(*connection);
        query_result = txn.exec_params(
            "SELECT * FROM (SELECT m.id, m.chat_id, m.sender_id, "
            "m.reply_to_id, m.content AS message_content, "
            "date_trunc('second', m.sent_at) AS sent_at, "
            "replied_message.content AS replied_message_content, "
            "u.username, m.has_reply, m.is_deleted, date_trunc('second', m.last_edited) as last_edited, "
            "replied_message.is_deleted as is_reply_deleted, "
            "replied_message.sender_id as reply_to_user_id, "
            "replied_user.username as reply_to_username, m.is_read "
            "FROM public.message AS m  "
            "LEFT JOIN public.message AS replied_message ON m.reply_to_id = replied_message.id "
            "JOIN public.users AS u ON m.sender_id = u.id  "
            "LEFT JOIN public.users AS replied_user ON replied_message.sender_id = replied_user.id "
            "WHERE (NOT m.is_deleted) AND "
            "m.chat_id = $1::integer AND "
            "m.id < $2::integer AND "
            "( ($3) OR (m.content LIKE '%' || $4 || '%' ESCAPE '\\') ) AND "
            "( (NOT $5) OR (m.sent_at >= $6::timestamptz AND m.sent_at <= $7::timestamptz) ) AND "
            "( (NOT $9) OR (NOT m.is_read AND m.sender_id != $10::integer) ) "
            "ORDER BY m.id DESC "
            "LIMIT $8) "
            "ORDER BY 1",
            chat_id, upper_msg_id, 
            static_cast<bool>(filter_content.length() == 0), filter_content,
            filter_dt_enabled, filter_dt_begin, filter_dt_end,
            max_msg_amount,
            filter_unread_enabled, logon_user_id
        );
        txn.commit();
        response["success"] = 1;
        response["messages"] = getChatMessages(query_result);
    }

    catch (pqxx::sql_error const& e)
    {
        response["success"] = 0;
        response["reason"] = std::string("pqxx::sql_error occurred: ") + e.what();
    }

    catch (std::exception const& e)
    {
        response["success"] = 0;
        response["reason"] = std::string("std::exception occurred: ") + e.what();
    }

    return response;
}


json DatabaseConnection::requestLowerMsgsHandler(json const& js)
{
    json response;
    pqxx::result query_result;
    int64_t const chat_id = js["chat_id"].get<int64_t>();
    int64_t const lower_msg_id = js["lower_msg_id"].get<int64_t>();
    
    std::string const filter_content = js["filter_content"].get<std::string>();
    bool const filter_dt_enabled = js["filter_dt_enabled"].get<bool>();
    
    // If datetime filter is disabled, we put the dummy values here
    std::string const filter_dt_begin = filter_dt_enabled ? 
    js["filter_dt_begin"].get<std::string>() : "2000-01-01 00:00:00Z";
    std::string const filter_dt_end = filter_dt_enabled ? 
    js["filter_dt_end"].get<std::string>() : "2000-01-01 00:00:00Z";

    int64_t const max_msg_amount = js["max_msg_amount"].get<int64_t>();
    
    bool const filter_unread_enabled = js["filter_unread_enabled"].get<bool>();
    int64_t const logon_user_id = js["user_id"].get<int64_t>();
    try
    {
        std::lock_guard<std::mutex> lock(mutex);
        pqxx::work txn(*connection);
        query_result = txn.exec_params(
            "SELECT m.id, m.chat_id, m.sender_id, "
            "m.reply_to_id, m.content AS message_content, "
            "date_trunc('second', m.sent_at) AS sent_at, "
            "replied_message.content AS replied_message_content, "
            "u.username, m.has_reply, m.is_deleted, date_trunc('second', m.last_edited) as last_edited, "
            "replied_message.is_deleted as is_reply_deleted, "
            "replied_message.sender_id as reply_to_user_id, "
            "replied_user.username as reply_to_username, m.is_read "
            "FROM public.message AS m  "
            "LEFT JOIN public.message AS replied_message ON m.reply_to_id = replied_message.id "
            "JOIN public.users AS u ON m.sender_id = u.id  "
            "LEFT JOIN public.users AS replied_user ON replied_message.sender_id = replied_user.id "
            "WHERE (NOT m.is_deleted) AND "
            "m.chat_id = $1::integer AND "
            "m.id > $2::integer AND "
            "( ($3) OR (m.content LIKE '%' || $4 || '%' ESCAPE '\\') ) AND "
            "( (NOT $5) OR (m.sent_at >= $6::timestamptz AND m.sent_at <= $7::timestamptz) ) AND "
            "( (NOT $9) OR (NOT m.is_read AND m.sender_id != $10::integer) ) "
            "ORDER BY m.id ASC "
            "LIMIT $8",
            chat_id, lower_msg_id, 
            static_cast<bool>(filter_content.length() == 0), filter_content,
            filter_dt_enabled, filter_dt_begin, filter_dt_end,
            max_msg_amount,
            filter_unread_enabled, logon_user_id
        );
        txn.commit();
        response["success"] = 1;
        response["messages"] = getChatMessages(query_result);
    }

    catch (pqxx::sql_error const& e)
    {
        response["success"] = 0;
        response["reason"] = std::string("pqxx::sql_error occurred: ") + e.what();
    }

    catch (std::exception const& e)
    {
        response["success"] = 0;
        response["reason"] = std::string("std::exception occurred: ") + e.what();
    }

    return response;
}


json DatabaseConnection::updateFrontendMsgs(json const& js)
{
    json response;
    pqxx::result query_result;
    int64_t const logon_user_id = js["logon_user_id"].get<int64_t>();
    std::vector<int64_t> const msg_ids = js["messages"].get<std::vector<int64_t>>();
    int64_t const pending_msg_id = js.value("pending_msg_id", static_cast<int64_t>(0));
    try
    {
        std::lock_guard<std::mutex> lock(mutex);
        pqxx::work txn(*connection);
        query_result = txn.exec_params(
            "UPDATE message "
            "SET is_read = TRUE "
            "WHERE id = ANY($1) AND "
            "is_read = FALSE AND "
            "sender_id != $2::integer",
            msg_ids, logon_user_id
        );

        query_result = txn.exec_params(
            "SELECT m.id, m.chat_id, m.sender_id, "
            "m.reply_to_id, m.content AS message_content, "
            "date_trunc('second', m.sent_at) AS sent_at, "
            "replied_message.content AS replied_message_content, "
            "u.username, m.has_reply, m.is_deleted, date_trunc('second', m.last_edited), replied_message.is_deleted, "
            "replied_message.sender_id, replied_user.username, m.is_read "
            "FROM public.message AS m "
            "LEFT JOIN public.message AS replied_message ON m.reply_to_id = replied_message.id "
            "JOIN public.users AS u ON m.sender_id = u.id "
            "LEFT JOIN public.users AS replied_user ON replied_message.sender_id = replied_user.id "
            "WHERE m.id = ANY($1) "
            "ORDER BY m.id ASC",
            msg_ids
        );
        response["messages"] = getChatMessages(query_result);


        query_result = txn.exec_params(
            "SELECT m.id, m.chat_id, m.sender_id, "
            "m.reply_to_id, m.content AS message_content, "
            "date_trunc('second', m.sent_at) AS sent_at, "
            "replied_message.content AS replied_message_content, "
            "u.username, m.has_reply, m.is_deleted, date_trunc('second', m.last_edited), replied_message.is_deleted, "
            "replied_message.sender_id, replied_user.username, m.is_read "
            "FROM public.message AS m "
            "LEFT JOIN public.message AS replied_message ON m.reply_to_id = replied_message.id "
            "JOIN public.users AS u ON m.sender_id = u.id "
            "LEFT JOIN public.users AS replied_user ON replied_message.sender_id = replied_user.id "
            "WHERE m.id = $1::integer "
            "ORDER BY m.id ASC",
            pending_msg_id // if 0 then empty result
        );

        txn.commit();
        
        // empty if no msg chosen to reply to/edit
        if (!query_result.empty()) 
        {
            response["pending_msg"] = getChatMessages(query_result);
        }
        response["success"] = 1;
    }

    catch (pqxx::sql_error const& e)
    {
        response["success"] = 0;
        response["reason"] = std::string("pqxx::sql_error occurred: ") + e.what();
    }

    catch (std::exception const& e)
    {
        response["success"] = 0;
        response["reason"] = std::string("std::exception occurred: ") + e.what();
    }
    return response;
}

json DatabaseConnection::gotoMsgHandler(json const& js)
{
    json response;
    pqxx::result query_result;
    int64_t const msg_id = js["id"].get<int64_t>();
    int64_t const chat_id = js["chat_id"].get<int64_t>();
    int64_t const max_chat_msgs = js["max_chat_msgs"].get<int64_t>();
    try
    {
        std::lock_guard<std::mutex> lock(mutex);
        pqxx::work txn(*connection);
        /*query_result = txn.exec_params(
            "WITH target AS (SELECT id FROM public.message "
            "WHERE id = $1::integer AND chat_id = $2::integer), "
            "before_messages AS ( "
            "SELECT m.* "
            "FROM public.message m "
            "WHERE m.chat_id = $2::integer AND  "
            "m.id < (SELECT id FROM target) "
            "ORDER BY m.id DESC LIMIT $3::integer), "
            "after_messages AS ( "
            "SELECT m.* "
            "FROM public.message m "
            "WHERE m.chat_id = $2::integer AND  "
            "m.id > (SELECT id FROM target) "
            "ORDER BY m.id LIMIT $4::integer), "
            "target_message AS ( "
            "SELECT m.* "
            "FROM public.message m "
            "WHERE m.id = $1::integer AND m.chat_id = $2::integer), "
            "full_set AS ( "
            "SELECT * FROM before_messages "
            "UNION ALL "
            "SELECT * FROM target_message "
            "UNION ALL "
            "SELECT * FROM after_messages) "
            "SELECT m.id, m.chat_id, m.sender_id,  "
            "m.reply_to_id, m.content AS message_content,  "
            "date_trunc('second', m.sent_at) AS sent_at,  "
            "replied_message.content AS replied_message_content,  "
            "u.username, m.has_reply, m.is_deleted,  "
            "date_trunc('second', m.last_edited) AS last_edited,  "
            "replied_message.is_deleted AS is_reply_deleted,  "
            "replied_message.sender_id AS reply_to_user_id,  "
            "replied_user.username AS reply_to_username, m.is_read "
            "FROM full_set m "
            "LEFT JOIN public.message AS replied_message ON m.reply_to_id = replied_message.id "
            "JOIN public.users AS u ON m.sender_id = u.id "
            "LEFT JOIN public.users AS replied_user ON replied_message.sender_id = replied_user.id "
            "ORDER BY m.id",
            msg_id, chat_id,
            max_chat_msgs/2 + (max_chat_msgs % 2) - 1,
            max_chat_msgs/2

        );*/
        query_result = txn.exec_params(
            "WITH RECURSIVE "
            "params AS ( "
            "SELECT "
            "$3::integer AS total_messages, "
            "$4::integer AS preferred_before), "
            "target AS ( "
            "SELECT id FROM public.message "
            "WHERE id = $1::integer AND chat_id = $2::integer), "
            "before_messages_raw AS ( "
            "SELECT m.*, ROW_NUMBER() OVER (ORDER BY m.id DESC) AS rn "
            "FROM public.message m, target "
            "WHERE m.chat_id = $2::integer AND m.id < target.id AND NOT m.is_deleted), "
            "after_messages_raw AS ( "
            "SELECT m.*, ROW_NUMBER() OVER (ORDER BY m.id ASC) AS rn "
            "FROM public.message m, target "
            "WHERE m.chat_id = $2::integer AND m.id > target.id AND NOT m.is_deleted), "
            "before_count AS ( "
            "SELECT COUNT(*)::integer AS cnt FROM before_messages_raw), "
            "after_count AS ( "
            "SELECT COUNT(*)::integer AS cnt FROM after_messages_raw), "
            "limits AS ( "
            "SELECT  "
            "p.total_messages, "
            "p.preferred_before, "
            "LEAST(p.preferred_before, bc.cnt) AS before_limit, "
            "LEAST(p.total_messages - 1 - LEAST(p.preferred_before, bc.cnt), ac.cnt) AS after_limit "
            "FROM params p "
            "JOIN before_count bc ON true "
            "JOIN after_count ac ON true), "
            "before_messages AS ( "
            "SELECT m.* "
            "FROM before_messages_raw m, limits "
            "WHERE m.rn <= limits.before_limit), "
            "after_messages AS ( "
            "SELECT m.* "
            "FROM after_messages_raw m, limits "
            "WHERE m.rn <= limits.after_limit), "
            "target_message AS ( "
            "SELECT *, 0 AS rn "
            "FROM public.message "
            "WHERE id = $1::integer AND chat_id = $2::integer), "
            "full_set AS ( "
            "SELECT * FROM before_messages "
            "UNION ALL "
            "SELECT * FROM target_message "
            "UNION ALL "
            "SELECT * FROM after_messages) "
            "SELECT m.id, m.chat_id, m.sender_id, "
            "m.reply_to_id, m.content AS message_content, "
            "date_trunc('second', m.sent_at) AS sent_at, "
            "replied_message.content AS replied_message_content, "
            "u.username, m.has_reply, m.is_deleted, "
            "date_trunc('second', m.last_edited) AS last_edited, "
            "replied_message.is_deleted AS is_reply_deleted, "
            "replied_message.sender_id AS reply_to_user_id, "
            "replied_user.username AS reply_to_username, m.is_read "
            "FROM full_set m "
            "LEFT JOIN public.message AS replied_message ON m.reply_to_id = replied_message.id "
            "JOIN public.users AS u ON m.sender_id = u.id "
            "LEFT JOIN public.users AS replied_user ON replied_message.sender_id = replied_user.id "
            "ORDER BY m.id",
            msg_id, chat_id, 
            max_chat_msgs, 
            max_chat_msgs/2 + (max_chat_msgs % 2) - 1
        );
        txn.commit();
        response["success"] = 1;
        response["msg_id"] = msg_id;
        response["messages"] = getChatMessages(query_result);
    }

    catch (pqxx::sql_error const& e)
    {
        response["success"] = 0;
        response["reason"] = std::string("pqxx::sql_error occurred: ") + e.what();
    }

    catch (std::exception const& e)
    {
        response["success"] = 0;
        response["reason"] = std::string("std::exception occurred: ") + e.what();
    }

    return response;
}

json DatabaseConnection::changeOnlineStatusHandler(json const& js)
{
    json response;
    int64_t const logon_user_id = js["id"].get<int64_t>();
    bool const is_online = js["is_online"].get<bool>();
    try
    {
        std::lock_guard<std::mutex> lock(mutex);
        pqxx::work txn(*connection);
        if (is_online)
        txn.exec_params(
            "UPDATE users "
            "SET is_online = TRUE "
            "WHERE id = $1",
            logon_user_id
        );
        else
        txn.exec_params(
            "UPDATE users "
            "SET is_online = FALSE, last_seen_online = NOW() "
            "WHERE id = $1 AND is_online = TRUE",
            logon_user_id
        );
        txn.commit();
        response["success"] = 1;
    }

    catch (pqxx::sql_error const& e)
    {
        response["success"] = 0;
        response["reason"] = std::string("pqxx::sql_error occurred: ") + e.what();
    }

    catch (std::exception const& e)
    {
        response["success"] = 0;
        response["reason"] = std::string("std::exception occurred: ") + e.what();
    }
    return response;
}

json DatabaseConnection::countUnreadMsgsHandler(json const& js)
{
    json response;
    pqxx::result query_result;
    int64_t const chat_id = js["chat_id"].get<int64_t>();
    int64_t const logon_user_id = js["logon_user_id"].get<int64_t>();
    int64_t const chat_top_msg = js["chat_top_msg"].get<int64_t>();
    int64_t const chat_bottom_msg = js["chat_bottom_msg"].get<int64_t>();
    try
    {
        std::lock_guard<std::mutex> lock(mutex);
        pqxx::work txn(*connection);
        query_result = txn.exec_params(
            "SELECT "
            "COUNT(CASE WHEN m.id < $1::integer THEN 1 END), "
            "COUNT(CASE WHEN m.id BETWEEN $1::integer AND $2::integer THEN 1 END), "
            "COUNT(CASE WHEN m.id > $2::integer THEN 1 END) "
            "FROM message m "
            "WHERE "
            "NOT m.is_deleted AND "
            "NOT m.is_read AND "
            "m.chat_id = $3::integer AND "
            "m.sender_id != $4::integer",
            chat_top_msg, chat_bottom_msg,
            chat_id, logon_user_id
        );
        txn.commit();
        response["success"] = 1;
        response["above"] = query_result[0][0].as<int64_t>();
        response["inside"] = query_result[0][1].as<int64_t>();
        response["below"] = query_result[0][2].as<int64_t>();
    }

    catch (pqxx::sql_error const& e)
    {
        response["success"] = 0;
        response["reason"] = std::string("pqxx::sql_error occurred: ") + e.what();
    }

    catch (std::exception const& e)
    {
        response["success"] = 0;
        response["reason"] = std::string("std::exception occurred: ") + e.what();
    }
    return response;
}