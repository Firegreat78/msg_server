// Copyright 2025 Medvedev Dan (https://github.com/Firegreat78)

/*
Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
*/

#include "ClientConnection.h"
#include "DatabaseConnection.h"
#include "Logger.h"

#include "json.hpp"
using json = nlohmann::json;

#include <string>
#include <vector>

ClientConnection::ClientConnection(SOCKET& socket, size_t const thread_id)
: socket(socket), thread_id(thread_id), pendingDelete(false), incomplete_json("")
{
    setRecvTimeout(10000);
    setSendTimeout(10000);
    this->thread = std::thread(&ClientConnection::handle_client, this);
}

ClientConnection::~ClientConnection()
{
    closesocket(socket);
    std::string const msg = std::string("Client with thread id ") + 
    this->getClientInfo() + "has disconnected from the server.";
    Logger::getInstance().log(msg);
}



// For each json we received from the client, we generate a 
// corresponding json which will be sent to the client.
json generateResponse(json const& js)
{
    DatabaseConnection& conn = DatabaseConnection::getInstance();
    Logger& logger = Logger::getInstance();
    logger.log(std::string("Preparing to handle incoming JSON: ") + js.dump());
    json response;
    try
    {
        std::string const type = js["type"].get<std::string>();
        response["type"] = type + "Response";

        if (type == "userLogin") response["response"] = conn.loginHandler(js);
        else if (type == "userRegister") response["response"] = conn.registerHandler(js);
        else if (type == "changeUsername") response["response"] = conn.changeUsernameHandler(js);
        else if (type == "changePassword") response["response"] = conn.changePasswordHandler(js);
        else if (type == "exitAccount") response["response"] = conn.exitAccountHandler(js);
        else if (type == "updateChatList") response["response"] = conn.updateChatListHandler(js);
        else if (type == "loadChat") response["response"] = conn.chatLoadHandler(js);
        else if (type == "loadChatFilter") response["response"] = conn.chatLoadFilterHandler(js);
        else if (type == "sendMessage") response["response"] = conn.sendMsgHandler(js);
        else if (type == "updateMessage") response["response"] = conn.updateMessageHandler(js);
        else if (type == "deleteMessage") response["response"] = conn.deleteMessageHandler(js);
        else if (type == "requestArrivedMessages") response["response"] = conn.getArrivedMsgHandler(js);
        else if (type == "requestUpperMsgs") response["response"] = conn.requestUpperMsgsHandler(js);
        else if (type == "requestLowerMsgs") response["response"] = conn.requestLowerMsgsHandler(js);
        else if (type == "gotoMsg") response["response"] = conn.gotoMsgHandler(js);
        else if (type == "updateFrontendMsgs") response["response"] = conn.updateFrontendMsgs(js);
        else if (type == "changeOnlineStatus") response["response"] = conn.changeOnlineStatusHandler(js);
        else if (type == "updateUsersList") response["response"] = conn.renewChatListInfoHandler(js);
        else if (type == "countUnread") response["response"] = conn.countUnreadMsgsHandler(js);
    }

    catch (json::parse_error const& e)
    {
        std::string const msg = 
            std::string("json::parse_error exception was thrown in the generateResponse function. "
            "Check and debug socket-related code. Exception: ") + e.what();
        Logger::getInstance().log(msg);
        response["type"] = "error";
        response["info"] = "JSON parse error.";
    }

    catch (std::exception const& e)
    {
        std::string const msg = 
            std::string("Some exception was thrown in the generateResponse function. "
            "Exception: ") + e.what();
        Logger::getInstance().log(msg);
        response["type"] = "error";
        response["info"] = std::string("Unknown error: ") + e.what();
    }
    return response;
}

// All data might not be sent simultaneously. We need to sent it in a loop to ensure that all data will be sent.
bool ClientConnection::sendAll(std::string const& data)
{
    Logger& logger = Logger::getInstance();
    logger.log(std::string("Preparing to send data: ") + data);
    size_t total_sent = 0;

    while (total_sent < data.length())
    {
        int const bytes_sent = send(this->socket, data.data() + total_sent, data.length() - total_sent, 0);
        if (bytes_sent == SOCKET_ERROR)
        {
            // 10053 - An established connection was aborted by the software in your host machine.
            // 10054 - Connection reset by peer.
            std::string msg = std::string("Socket error on send(): ") + std::to_string(WSAGetLastError());
            logger.log(msg);
            return false;
        }
        std::string const data_sent = data.substr(total_sent, data.length() - total_sent);
        logger.log(std::string("Data sent: ") + data_sent);
        total_sent += bytes_sent;
    }
    return true;
}

void ClientConnection::handle_client(ClientConnection* const conn)
{
    Logger& logger = Logger::getInstance();
        
    try
    {
        while (!conn->pendingDelete)
        {
            conn->bytes_received = recv(conn->socket, conn->recv_buf.data(), sizeof (conn->recv_buf) - 1, 0);
            int const wsa_last_error = WSAGetLastError();
            if (conn->bytes_received > 0) conn->onBytesReceived();
            else if (conn->bytes_received == 0) // graceful socket shutdown
            {
                std::string const msg = std::string("Client " ) +
                conn->getClientInfo() + 
                " has disconnected from the server (recv zero bytes).";
                logger.log(msg);
                conn->pendingDelete = true;
            }

            else if (wsa_last_error == WSAETIMEDOUT) // recv timeout (no heartbeat from the client...)
            {
                std::string const msg = std::string("Heartbeat timed out from client ") + 
                conn->getClientInfo();
                logger.log(msg);
                //conn->pendingDelete = true;
            }

            else // other socket error
            {
                std::string const msg = std::string("Socket error occured for client ") + 
                conn->getClientInfo() + ": " + std::to_string(wsa_last_error);
                logger.log(msg);
                conn->pendingDelete = true;
            }

            for (auto const& js_from_client : conn->jsons_from_client)
            {
                json const js_to_client = generateResponse(js_from_client);
                conn->jsons_to_client.push_back(js_to_client);
                std::string const type = js_to_client["type"].get<std::string>();
                
                // We count the amount of successful logins so we can track whether one of the devices is logon
                // into some account at some monent in time. Later, if connection closes (conn->pendingDelete = true), 
                // or user exits from their account,
                // we decrement the counter. If it hits zero, we update the database and set 'is_online' for that user to false.
                
                if (type == "userLoginResponse")
                {
                    if (js_to_client["response"]["success"].get<int64_t>() == 0) continue;

                    int64_t const logon_user_id = js_to_client["response"]["id"].get<int64_t>();
                    DatabaseConnection::getInstance().addLogonUser(conn->thread_id, logon_user_id); 
                }
                else if (type == "exitAccountResponse")
                {
                    if (js_to_client["response"]["success"].get<int64_t>() == 0) continue;

                    // Now this socket is not handling the user, so we decrement the counter
                    DatabaseConnection::getInstance().onLogonUserDisconnect(conn->thread_id);
                }
            }

            for (auto const& js_to_client : conn->jsons_to_client)
            {
                std::string const data = js_to_client.dump();
                bool const send_success = conn->sendAll(data);
                if (!send_success) 
                {
                    std::string const msg = std::string("Failed to send JSON.");
                    logger.log(msg);
                    conn->pendingDelete = true;
                }
            }

            conn->jsons_from_client.clear();
            conn->jsons_to_client.clear();
        }
    }

    catch (std::exception const& e)
    {
        logger.log(std::string("An exception occurred inside handle_client function:") + e.what());
    }
}

// recv() may give an incomplete json.
// For example:
// {"type":"heartbeat","value":52}{"type":"heartbeat","val
// The first JSON is complete, the second one is incomplete.
// To determine the completeness of an json, we use bracket-depth method.
size_t getFirstCompletedIndex(std::string const& chunk)
{
    int depth = 0;
    bool insideString = false;

    for (size_t i = 0; i < chunk.size(); i++)
    {
        char const c = chunk[i];

        if (c == '"')
        {
            size_t bs = 0; // backslashes
            size_t k = i;
            while (k > 0 && chunk[k-1] == '\\')
            {
                ++bs;
                --k;
            }
            if ((bs % 2) == 0) insideString = !insideString;
        }
        
        if (insideString) continue;

        if (c == '{') ++depth;
        if (c == '}') --depth;

        if (depth == 0 && c == '}') return i + 1;
    }
    return 0;
}

void ClientConnection::onBytesReceived()
{
    recv_buf[bytes_received] = 0;
    std::string chunk = incomplete_json + std::string(recv_buf.data());
    while (true)
    {
        size_t const index = getFirstCompletedIndex(chunk);
        if (index == 0) break;
        std::string const json_first = chunk.substr(0, index);
        jsons_from_client.push_back(json::parse(json_first));
        chunk = chunk.substr(index);
    }
    incomplete_json += chunk;
}

std::string ClientConnection::getClientInfo()
{
    return std::string("(socket=") + 
    std::to_string(this->socket) + 
    "; thread_id=" + 
    std::to_string(this->thread_id) + 
    ")";
}

void ClientConnection::setRecvTimeout(int millis)
{
    Logger& logger = Logger::getInstance();
    if (setsockopt(socket, SOL_SOCKET, SO_RCVTIMEO, reinterpret_cast<const char*>(&millis), sizeof(millis)) == SOCKET_ERROR)
    {
        auto msg = std::string("Failed to set socket option for data receive timeout. Socket: ") + std::to_string(socket);
        logger.log(msg);
        throw std::runtime_error(msg);
    }
    auto msg = std::string("Set socket option for data receive timeout successfully. Socket: ") + std::to_string(socket);
}

void ClientConnection::setSendTimeout(int millis)
{
    Logger& logger = Logger::getInstance();
    if (setsockopt(socket, SOL_SOCKET, SO_SNDTIMEO, reinterpret_cast<const char*>(&millis), sizeof(millis)) == SOCKET_ERROR)
    {
        auto msg = std::string("Failed to set socket option for data send timeout. Socket: ") + std::to_string(socket);
        logger.log(msg);
        throw std::runtime_error(msg);
    }
    auto msg = std::string("Set socket option for data send timeout successfully. Socket: ") + std::to_string(socket);
}

bool ClientConnection::isPendingToDelete() const
{
    return this->pendingDelete;
}

void ClientConnection::joinThread()
{
    if (this->thread.joinable()) this->thread.join();
}