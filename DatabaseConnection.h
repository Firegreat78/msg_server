// Copyright 2025 Medvedev Dan (https://github.com/Firegreat78)

/*
Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
*/

#ifndef DATABASECONNECTION_H
#define DATABASECONNECTION_H

#include "pqxx/pqxx"

#include "json.hpp"
using json = nlohmann::json;

#include <mutex>
#include <memory>
#include <map>

class DatabaseConnection
{
    // All database queries must not be executed at the same time from any two threads
    std::mutex mutex;
    
    // Use unique_ptr because pqxx::connection default ctor will throw
    std::unique_ptr<pqxx::connection> connection = nullptr;

    // We store user_id here so we can set online status to false if socket times out
    std::map<size_t, int64_t> logon_user_ids;
    
    // Map key - logon user id
    // Map value - amount of logon clients for this user
    // When the counter goes to zero, we update the DB and set online status to false
    std::map<int64_t, int64_t> users_amount;

    DatabaseConnection();
    DatabaseConnection(const DatabaseConnection&) = delete;
    DatabaseConnection& operator=(const DatabaseConnection&) = delete;

    // No std::lock_guard here because this method is called 
    // in thread-safe context (inside another lock_guard).
    //
    // pqxx::result must contain a specific set of fields here, be cautious on change.
    json getChatMessages(pqxx::result const&);

    public:
    ~DatabaseConnection();
    static DatabaseConnection& getInstance();

    // These two (addLogonUser, onLogonUserDisconnect) for handling online status in case of socket errors
    // They will update is_online status for user in the database.
    // Should also work in case when two clients login to the same account but in different apps
    void addLogonUser(size_t, int64_t);
    void onLogonUserDisconnect(size_t);

    json loginHandler(json const&);
    json registerHandler(json const&);
    
    json changeUsernameHandler(json const&);
    json changePasswordHandler(json const&);

    json exitAccountHandler(json const&);
    
    // Chat list after registration
    // TODO: group chats
    json updateChatListHandler(json const&);

    // Update chat list info without prefetching new info
    json renewChatListInfoHandler(json const&);
    
    // This preloads last N messages from a chat (when user opens it on client)
    json chatLoadHandler(json const&);
    json chatLoadFilterHandler(json const&);
        
    // Adds a message to the DB.
    json sendMsgHandler(json const&);

    // updates the message's content
    json updateMessageHandler(json const&);

    // delete msg
    json deleteMessageHandler(json const&);
    
    // We will request newly arrived msgs if there are
    // less than N messages in chat's scope
    json getArrivedMsgHandler(json const&);

    // This preloads N additional messages each time the user scrolls up/down just enough
    // (we take filters into account here)
    json requestUpperMsgsHandler(json const&);
    json requestLowerMsgsHandler(json const&);

    // Update visible msg data
    json updateFrontendMsgs(json const&);

    // Loads N messages before and after a certain message.
    // (note: this does not take filters into account)
    json gotoMsgHandler(json const&);

    // If window is not in focus - user is offline
    json changeOnlineStatusHandler(json const&);

    // For counting unread msgs above/inside/below the chat's scope.
    json countUnreadMsgsHandler(json const&);
};

#endif // DATABASECONNECTION_H